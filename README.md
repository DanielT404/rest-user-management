![Architecture](https://cv-variants-bucket.s3.eu-central-1.amazonaws.com/architecture.png)

## How to run the application

1. `git clone https://github.com/DanielT404/rest-user-management.git` to your own path of choice.
2. Wanna test it out without having to install the dependencies locally? Just run `docker-compose up --build -d`.
3. App is now ready to handle incoming requests on port 3000.

## Database used

MongoDB.

## User schema

An user is stored in the database with the following fields:

- \_id: 12-byte string to uniquely identify a record, generated by MongoDB.
- username: string, unique, UTF-8 encoded
- hash: 64-byte string, unique (96.83% probably), hex encoded, representing the encryption of the plain-text user password and a random salt.
- salt: 64-byte string, unique (95.38% probably), hex encoded, representing an unique key that has been used to compute the final hash.
- blacklisted: boolean[true | false], representing if a given user is blacklisted from using the services.
- roles: Array<string> - accepted strings: "guest" or "admin"
- permissions: Array<ResourceActionScope[]>
  - ResourceActionScope[] = { action: "self" | "all", method: "GET" | "POST" | "PATCH" | "DELETE", resource: string = 'users' }
- refresh_token: 64-byte string, hex encoded, unique, representing a temporary token for each user to authenticate again.
- created_at: string<DateTime>, ISO-8601 string, representing the registration date of the user.
- updated_at: string<DateTime>, ISO-8601 string, representing the last user-related modifications date.

## Authentication & Authorization

Both the authentication and authorization are made with self-signed, RS512-based algorithm JWT that expires every minute.
When the user is succesfully logged in, on each subsequent request there will be:

- 1.  an unique access_token - the JWT token of the user, sent as cookie, which expires every 1 minute.
- 2.  an unique refresh_token - sent as cookie, used to refresh the access_token once it expires

Cookies are sent with the `SameSite=lax`, `HttpOnly` and `Strict=true` policies.

## API requests

Send the fields required in the body of the request as JSON.

## API versioning

Keeping it simple by prepending the resource with the current version.
Current version: v1

## Available API routes

### Group /v1

1. GET /users/me - get current logged in user.
2. GET /users - get all users | available to users with ResourceActionScope[]{ action: "all", method: "GET"}
3. GET /users/:\_id - get an user by ID | available to users with ResourceActionScope[]{ action: "self" | "all", method: "GET"}
4. POST /users - create a new user
   ### Required fields:
   - username: not empty | unique
   - password: not empty | min. 8 characters
   ### Authorized-only fields:
   - roles
   - permissions
   ### Optional headers:
   - X-Auth-Token || create a default admin user with the x-auth-token key generated on app initialization.
5. PATCH /users/:id - update an existing user field.
   ### Optional fields:
   - username: to modify the username
   - password: to modify the password
   ### Authorized-only fields:
   - roles
   - permissions
   - blacklisted
6. DELETE /users/:id - delete an existing user

7. POST /login - authentication
   ### Required fields:
   - username
   - password
8. GET /refresh/jwt - refresh the JWT token associated with the user once the access_token expires (every minute).
